---
title: qntmap `r packageVersion("qntmap")`
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
params:
  xmap: NULL
  qnt: NULL
  deadtime: 0
runtime: shiny
---

```{css, echo = FALSE}
.btn.radiobtn.btn-secondary.active {background: #2780e3; color: white;}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, cache = TRUE)
library(DT)
library(dplyr)
library(flexdashboard)
library(ggAtusy)
library(ggplot2)
library(htmltools)
library(knitr)
library(purrr)
library(pipeR)
library(qntmap)
library(scales)
library(shinyWidgets)
library(tibble)
library(tidyr)

example <- system.file(package = "qntmap", "extdata", "minimal")
dir_xmap <- `if`(is.null(params$xmap), file.path(example, ".map/1"), params$xmap)
dir_qnt <- `if`(is.null(params$qnt), file.path(example, ".qnt"), params$qnt)

# Read demo files if params xmap and qnt are unset
.env <- new.env()
xmap0 <- read_xmap(dir_xmap, DT = params$deadtime)
xmap <- function() xmap0
qnt <- read_qnt(dir_qnt, saving = FALSE)
epma <- tidy_epma(qnt, xmap()) %>>% qntmap:::prioritize("id")
.margin <- c(-.5, .5)
range_x <- range(xmap()$x)
range_y <- range(xmap()$y)

.env$xmap$summary <- xmap() %>>%
  summarize_if(is.numeric, mean) %>>%
  mutate(ID = 0L, Area = "Whole") %>>%
  select("ID", "Area", "x", "y", everything())
.env$cluster$result <- xmap()[c("x", "y")] %>>%
  mutate(cluster = "NA") %>>%
  structure(class = c("qm_cluster", "data.frame"))
.env$cluster$summary <- .env$cluster$result %>>%
  summarize_if(is.numeric, mean) %>>%
  mutate(ID = 0L, Area = "Whole") %>>%
  select("ID", "Area", "x", "y", everything())
.env$qmap$element <- qnt$elm %>>%
  filter(elint %in% names(xmap())) %>>%
  `[[`("elem")
.env$qmap$result <- xmap()[c("x", "y")] %>>%
  mutate(!!!(setNames(as.list(numeric(length(.env$qmap$element))), .env$qmap$element))) %>>%
  structure(class = c("qntmap", class(.)))
.env$qmap$summary <- .env$qmap$result %>>%
  summarize_if(is.numeric, mean) %>>%
  mutate(ID = 0L, Area = "Whole") %>>%
  select("ID", "Area", "x", "y", everything())

msg <- list(
  action = c(
    Zoom = "Zoom by double click selected area. Pan by double click again.",
    Move = "Move by double click within zoomed area.",
    Summarize = "Double click or select area to save data."
  )
)
```

```{r setup-functions}
summarize_box <- function(data, box, .env, .key) {
  id <- .env[[.key]]$summary$ID[[1L]]
  if (is.null(id)) id <- 0L
  .env[[.key]]$summary <- data()[
    box$xmin <= data()$x & data()$x <= box$xmax &
      box$ymin <= data()$y & data()$y <= box$ymax,
  ] %>>%
    summarize_if(is.numeric, mean) %>>%
    mutate(ID = !!id + 1L, Area = "Box", membership = NULL) %>>%
    select("ID", "Area", "x", "y", everything()) %>>%
    filter(is.finite(x), is.finite(y)) %>>%
    bind_rows(.env[[.key]]$summary)
  .env[[.key]]$summary
}


summarize_click <- function(data, click, .env, .key) {
  x <- round(click$x)
  y <- round(click$y)
  
  if (identical(
    as.list(.env[[.key]]$summary[1L, c("x", "y", "Area")]),
    list(x = x, y = y, Area = "Click")
  )) {
    return(.env[[.key]]$summary)
  }
  
  id <- .env[[.key]]$summary$ID[[1L]]
  
  if (is.null(id)) id <- 0L
  .env[[.key]]$summary <- data()[data()$x == x & data()$y == y, ] %>>%
    mutate(ID = !!id + 1L, Area = "Click", membership = NULL) %>>%
    select("ID", "Area", "x", "y", everything()) %>>%
    bind_rows(.env[[.key]]$summary)
  .env[[.key]]$summary
}

select_action <- function(id) {
  radioGroupButtons(
    inputId = id,
    label = "Mouse actions",
    choices = c("Zoom", "Move", "Summarize"),
    selected = "Zoom",
    status = "secondary",
    individual = TRUE
  )
}

map_render <- function(id, map_reactive) {
  ids <- paste0(id, "_", c("click", "brush"))
  renderPlot(
    map_reactive(), 
    outputArgs = list(
      dblclick = ids[[1L]],
      brush = brushOpts(id = ids[[2L]], resetOnNew = TRUE)
    )
  )
}

raster_react <- function(x, ranges, .margin, zlim, input, id) {reactive({
  ids <- paste0(id, "_", c("elem", "color"))
  qntmap:::gg_img(
    x()[ranges$y[[1L]]:ranges$y[[2L]], ranges$x[[1L]]:ranges$x[[2L]], ],
    xlim = ranges$x + .margin, ylim = ranges$y + .margin,
    zlim = zlim(), zname = input[[ids[[1L]]]],
    colors = input[[ids[[2L]]]]
  )
})}

summarize_action_react <- function(df, input, id, .env) {reactive({
  ids <- paste0(id, "_", c("action", "brush", "click"))
  if (input[[ids[[1L]]]] != "Summarize") return(.env[[id]]$summary)
  if (!is.null(input[[ids[[2L]]]]))
    return(summarize_box(df, input[[ids[[2L]]]], .env, id))
  if (!is.null(input[[ids[[3L]]]]))
    return(summarize_click(df, input[[ids[[3L]]]], .env, id))
  .env[[id]]$summary
})}

summarize_latest_react <- function(df) {reactive({
  df() %>>%
    head(3) %>>%
    modify_if(is.numeric, function(x) sprintf("%.2f", x)) %>>%
    mutate(ID = as.integer(ID)) %>>%
    gather(Var, Val, -ID, factor_key = TRUE) %>>%
    spread(ID, Val) %>>%
    rename(ID = Var)
})}

zoom <- function(.axis, .input, .range) {
  if (is.null(.input)) return(.range)
  squish(
    c(.input[[paste0(.axis, "min")]], .input[[paste0(.axis, "max")]]), 
    .range
  )
}

move <- function(.axis, .input, .from, .to) {
  .range <- .from + c(1, -1) * (.to[2L] - .to[1L]) / 2
  .to - mean(.to) + squish(.input[[.axis]], .range)
}

observe_action <- function(id, input, ranges, range_x, range_y) {
  ids <- paste0(id, "_", c("click", "brush", "action"))
  observeEvent(input[[ids[[1L]]]], {
    if (input[[ids[[3L]]]] == "Zoom") {
      ranges$x <- zoom("x", input[[ids[[2L]]]], range_x)
      ranges$y <- zoom("y", input[[ids[[2L]]]], range_y)
    }
    if (input[[ids[[3L]]]] == "Move" && !is.null(ranges$x)) {
      ranges$x <- move("x", input[[ids[[1L]]]], range_x, ranges$x)
      ranges$y <- move("y", input[[ids[[1L]]]], range_y, ranges$y)
    }
  })
}

select_element_and_range <- function(id, choices, label = "Element") {
  ids <- paste0(id, "_", c("elem", "min", "max"))
  splitLayout(
    selectInput(
      ids[[1L]], label = label, choices = choices, selectize = FALSE
    ),
    numericInput(ids[[2L]], "Min", value = NA_real_),
    numericInput(ids[[3L]], "Max", value = NA_real_),
    cellWidths = 100
  )
}

select_color <- function(id) {
  selectInput(
    paste0(id, "_color"), label = "Color", 
    choices = c("viridis", "gray"), selectize = FALSE
  )
}

zlim_react <- function(id, map_reactive, input) {reactive({
  ids <- paste0(id, "_", c("elem", "min", "max"))
  z <- range(map_reactive()[[input[[ids[[1L]]]]]])
  .min <- input[[ids[[2L]]]]
  .max <- input[[ids[[3L]]]]
  c(
    `if`(is.na(.min) || .min < z[1L], z[1L], .min),
    `if`(is.na(.max) || .max > z[2L], z[2L], .max)
  )
})}

hist_react <- function(id, map_reactive, input) {reactive({
  ids <- paste0(id, "_", c("elem", "min", "max", "color"))
  qntmap:::gghist.numeric(
    unlist(map_reactive()[[input[[ids[[1L]]]]]], use.names = FALSE),
    .min = input[[ids[[2L]]]], .max = input[[ids[[3L]]]],
    colors = input[[ids[[4L]]]]
  )
})}

squish_react <- function(map_reactive, z, zlim_reactive) {reactive({
  squish(map_reactive()[[z]], zlim_reactive())
})}
```

```{r null, eval = FALSE}

```


# Map

## xmap-menu {data-width=200}

### Menu

```{r xmap-menu}
select_element_and_range("xmap", setdiff(names(xmap()), c("x", "y")))
select_color("xmap")
select_action("xmap_action")
```

```{r xmap-msg-action, cache = FALSE, eval=TRUE}
renderText(msg$action[[input$xmap_action]], outputArgs = list(inline = TRUE))
```

---

**Summarized** ([View full](#xmap-log))

```{r xmap-summarize, eval = TRUE, cache = FALSE}
xmap_df <- summarize_action_react(xmap, input, "xmap", .env)
xmap_df_latest <- summarize_latest_react(xmap_df)
renderTable(xmap_df_latest(), align = "r")
```


```{r xmap-zoom-move, eval = TRUE}
ranges <- reactiveValues(x = range_x, y = range_y)
observe_action("xmap", input, ranges, range_x, range_y)
observe_action("cluster", input, ranges, range_x, range_y)
observe_action("qmap", input, ranges, range_x, range_y)
```


## xmap-viewer {.tabset}

### Map

```{r xmap-raster}
xmap_zlim <- zlim_react("xmap", xmap, input)

xmap_squished <- squish_react(xmap, input$xmap_elem, xmap_zlim)

xmap_img <- reactive(qntmap:::as_img(
  qntmap:::lookup[[input$xmap_color]](xmap_squished(), from = xmap_zlim()),
  range_y[2L], range_x[2L]
))

xmap_rastered <- raster_react(xmap_img, ranges, .margin, xmap_zlim, input, "xmap")
```


```{r xmap-heatmap, cache=FALSE}
map_render("xmap", xmap_rastered)
```


### Histogram

```{r xmap-hist, cache = FALSE}
xmap_hist <- hist_react("xmap", xmap, input)
renderPlot(xmap_hist())
```

### Log {#xmap-log}

```{r xmap-full-summary, cache=FALSE}
renderDT(xmap_df())
```

### Analytical conditions

```{r cnd-map}
datatable(tribble(
  ~ Varables, ~ Values, ~ Units,
  "Elements", paste(setdiff(names(xmap()), c("x", "y")), collapse = ", "), "",
  "Dead time", attr(xmap(), "deadtime"), "nsec",
  "Dwell", attr(xmap(), "dwell"), "msec",
  "Probe current", attr(xmap(), "current"), "A",
  "Start X", attr(xmap(), "start")[[1L]], "mm",
  "Start Y", attr(xmap(), "start")[[2L]], "mm",
  "Start Z", attr(xmap(), "start")[[3L]], "mm",
  "Pixel size", attr(xmap(), "pixel")[[1L]], "μm",
  "Step size", attr(xmap(), "step")[[1L]], "μm",
  "Instrument", attr(xmap(), "instrument"), "",
  "Path", "dir_xmap", ""
))
```


# Spots

## qnt-menu {data-width=200}

### Phase list

- Edit by double click a cell
- Confirm by Ctrl + Enter

```{r, cache=FALSE}
.env$qnt$phase_list <- transmute(qnt$cnd, id, phase, use = TRUE)
output$qnt_phase_list <- renderDT(
  .env$qnt$phase_list,
  editable = list(target = "column", disable = list(columns = 0:1)),
  server = TRUE
)
DTOutput("qnt_phase_list")
observeEvent(input$qnt_phase_list_cell_edit, {
  .env$qnt$phase_list <- editData(
    .env$qnt$phase_list, input$qnt_phase_list_cell_edit, 'phase_list'
  )
})
```


## qnt-viwer {.tabset}

### Analytical conditions

```{r elm}
datatable(qnt$elm)
```

### Spots

```{r spot}
datatable(qnt$cnd)
```

### Wt%

```{r wt}
datatable(qnt$cmp$wt)
```

### Net

```{r net}
datatable(qnt$cmp$net)
```

### Peak

```{r pkint}
datatable(qnt$cmp$pkint)
```

### Background +

```{r bgp}
datatable(qnt$cmp$bgp)
```

### Background -

```{r bgm}
datatable(qnt$cmp$bgm)
```

# Check

## check-menu {data-width=200}

### Find outliers

The scatter plots on the right pane compares peak X-ray intensities of
X-ray maps ans spot analysis from the same pixels.
Regression curves are drawn by least squares with y-intercept = 0.

The outliers generally indicate that
they are analyzing multiple phases during mapping.


```{r select-outliers}
checkboxGroupInput(
  "outlier",
  "Select phases tend to be outliers",
  choices = sort(unique(qnt$cnd$phase))
)
```


## Find fine grained phases {.tabset}

```{r find-fine-grained, warning=FALSE, results='asis'}
epma %>>%
  filter(is.finite(mapint), is.finite(pkint)) %>>%
  split(.$elm) %>>%
  qntmap:::prioritize(qntmap:::.element) %>>%
  iwalk(~ {
    cat("\n\n###", .y, "\n\n")
    print(
      ggplot(.x, aes(mapint, pkint)) +
        geom_smooth(
          formula = y ~ 0 + x, color = "gray10", se = FALSE, method = "lm"
        ) +
        stat_err(aes(
          color = phase,
          xmin = mapint.L, xmax = mapint.H,
          ymin = pkint.L, ymax = pkint.H,
        )) +
        labs(x = "Peak (Map) [cps/uA]", y = "Peak (Spot) [cps/uA]") +
        theme_minimal()
    )
  }) %>>%
  invisible()
```

### Initial centroid

```{r init-centers, cache = FALSE}
centers <- reactive(find_centers(xmap(), qnt, fine_phase = input$outlier))
renderDT(centers())
```


# Cluster

## cluster-menu {data-width=200}

### Menu

```{r cluster-menu}
actionButton(
  "cluster_run", label = "Run cluster analysis", width = "90%",
  style = "background: #EE0000;"
)

select_action("cluster_action")
```


----

**Summarized** ([View full](#cluster-log))

```{r cluster-run}
cluster_out <- reactive({
  input$cluster_run
  isolate(if (input$cluster_run != 0L) {
    .env$cluster$result <- cluster_xmap(xmap(), centers())
    .env$cluster$summary <- .env$cluster$result %>>%
      summarize_if(is.numeric, mean) %>>%
      mutate(ID = 0L, Area = "Whole", membership = NULL) %>>%
      select("ID", "Area", "x", "y", everything())
  })
  .env$cluster$result
})
cluster_df <- summarize_action_react(cluster_out, input, "cluster", .env)
cluster_df_latest <- summarize_latest_react(cluster_df)
```

```{r cluster-summarize, eval = TRUE, cache = FALSE}
renderTable(cluster_df_latest(), align = "r")
```

## cluster-viewer {.tabset}

### Map

```{r cluster-heatmap, eval=TRUE, cache=FALSE}
cluster_zlim <- reactive(unique(cluster_out()$cluster))

cluster_img <- reactive(qntmap:::as_img(
  qntmap:::lookup[["discrete"]](cluster_out()$cluster),
  range_y[2L], range_x[2L]
))

cluster_rastered <- raster_react(cluster_img, ranges, .margin, cluster_zlim, input, "cluster")

map_render("cluster", cluster_rastered)
```

### Membership

```{r cluster-membership, cache = FALSE}
renderDT(cluster_out())
```

### Centroid

```{r cluster-centroid, cache = FALSE}
renderDT(attr(cluster_out(), "center"))
```

### Log {#cluster-log}

```{r cluster-full-summary, cache=FALSE}
renderDT(cluster_df())
```

# Quantify

## quantify-menu {data-width=200}

### Menu

```{r quantify-menu}
actionButton(
  "qmap_run", label = "Quantify Maps", width = "90%",
  style = "background: #EE0000;"
)
select_element_and_range("qmap", .env$qmap$element)
select_color("qmap")
select_action("qmap_action")
```


----

**Summarized** ([View full](#quantify-log))

```{r quantify-summarize, eval = TRUE, cache = FALSE}
qmap_df <- summarize_action_react(qmap_out, input, "qmap", .env)

qmap_df_latest <- summarize_latest_react(qmap_df)

renderTable(qmap_df_latest(), align = "r")
```


```{r quantify-run}
qmap_out <- reactive({
  input$qmap_run
  isolate(if (input$qmap_run != 0L && input$cluster_run != 0L) {
    .env$qmap$result <- quantify(
      xmap(), qnt, cluster_out(), fine_phase = input$outlier
    )
    .env$qmap$summary <- .env$qmap$result %>>%
      summarize_if(is.numeric, mean) %>>%
      mutate(ID = 0L, Area = "Whole", membership = NULL) %>>%
      select("ID", "Area", "x", "y", everything())
  })
  .env$qmap$result
})
```

## quantify-viewer {.tabset}

### Map


```{r quantify-raster}
qmap_zlim <- zlim_react("qmap", qmap_out, input)

qmap_squished <- squish_react(qmap_out, input$qmap_elem, qmap_zlim)

qmap_img <- reactive(qntmap:::as_img(
  qntmap:::lookup[[input$qmap_color]](qmap_squished(), from = qmap_zlim()),
  range_y[2L], range_x[2L]
))

qmap_rastered <- raster_react(qmap_img, ranges, .margin, qmap_zlim, input, "qmap")
```

```{r quantify-heatmap, cache=FALSE}
map_render("qmap", qmap_rastered)
```

### Histogram

```{r quantify-hist, cache = FALSE}
qmap_hist <- hist_react("qmap", qmap_out, input)
renderPlot(qmap_hist())
```

### Table

```{r quantify-table, cache=FALSE}
renderDT(qmap_out())
```


# Misc.

## miscellaneous-tabset {.tabset}

### Table

```{r tidy-epma}
datatable(epma)
```


### α

```{r alpha, warning=FALSE}
epma %>>%
  group_by(elm, phase) %>>%
  group_walk(~ print(
    ggplot(.x, aes(wt, pkint)) +
      geom_linerange(aes(ymin = pkint.L, ymax = pkint.H)) +
      geom_point() +
      facet_wrap(vars(!!paste(.y$phase, .y$elm))) +
      labs(
        x = "Peak (Map) [cps/uA]",
        y = "Peak (Spot) [cps/uA]"
      )
  )) %>>%
  invisible
```

### β

```{r beta, warning=FALSE}
epma %>>%
  group_by(elm) %>>%
  group_walk(~ print(
    ggplot(.x, aes(mapint, pkint, color = phase)) +
      stat_err(aes(
        xmin = mapint.L, xmax = mapint.H,
        ymin = pkint.L, ymax = pkint.H,
      )) +
      # geom_point() +
      facet_wrap(~ .y$elm) +
      labs(
        x = "Peak (Map) [cps/uA]",
        y = "Peak (Spot) [cps/uA]"
      )
  )) %>>%
  invisible
```


### γ

```{r gamma, warning=FALSE}
epma %>>%
  group_by(phase, elm) %>>%
  group_walk(~ print(
    ggplot(.x, aes(wt, bgint)) +
      geom_point() +
      geom_linerange(aes(ymin = bgint.L, ymax = bgint.H)) +
      facet_wrap(vars(!!paste(.y$phase, .y$elm))) +
      labs(x = "wt%", y = "Background [cps/uA]")
  )) %>>%
  invisible
```

