#' Initialize centroids
#' 
#' Initialize centroids for cluster analysis.
#'
#' @param phase_fine fine grained phases which tend to be appear in multi-phase pixels e.g., c('Pl', 'Amp')
#' @param qnt an qnt class object generated by read_qnt
#' @param xmap an xmap class object generated by read_xmap
#' @param saveas file name to save. FALSE if not saving.
#'
#' @importFrom data.table fwrite
#' @importFrom dplyr bind_cols
#' @importFrom dplyr bind_rows
#' @importFrom dplyr filter
#' @importFrom dplyr group_by
#' @importFrom dplyr mutate
#' @importFrom dplyr summarise
#' @importFrom dplyr ungroup
#' @importFrom pipeR pipeline
#' @importFrom stats lm
#' @importFrom stats predict
#' @importFrom stats qnbinom
#' @importFrom stats median
#' @importFrom tidyr spread
#'
#' @export
cluster_centers <- function(
  qnt,
  xmap,
  phase_fine = NULL,
  saveas = 'centers0.csv'
) {

  quantified <- names(xmap) %in% qnt$elm$elint
  xmap_df <- as.data.frame(lapply(xmap, unlist, use.names = FALSE))
  
  pipeline({
    epma_tidy( # Compile spot/map analysis
      qnt = qnt,
      xmap = xmap,
      cluster = NA
    )
    group_by(phase)
    filter(all(is.na(map)) | !is.na(map))
    ungroup
    mutate( # Let weighting for least squares to be 0 for phases those who listed in phase_fine
      w = if(is.null(phase_fine)) 1 else as.integer(phase %nin% phase_fine)
    )
    group_by(elint) # Peform least squares and estimate 99% prediction interval
    mutate(
      .tmp = is.finite(map),
      map_est =
        pkint * lsfit(pkint[.tmp], map[.tmp], w[.tmp], intercept = FALSE)$coef,
      map_fnite = NULL, 
      pi_L = qnbinom(0.005, map_est, 0.5),
      pi_H = qnbinom(0.995, map_est + 1, 0.5)
    )
    group_by(id)
    mutate( # See if values are within prediction interval
      within_pi = all((pi_L <= map) & (map <= pi_H))
    )
    group_by(elint, phase)
    mutate(n_within_pi = sum(within_pi))
    ungroup
    select(elint, map, map_est, within_pi, n_within_pi, phase, id, nr)
    bind_rows(
      if(!all(quantified)) {
        pipeline({
          .
          filter(elint == elint[1])
          select(-elint, -map, -map_est)
          bind_cols(
            lapply(xmap_df[!quantified], `[`, .$nr)
          )
          gather(
            elint, map, -within_pi, -n_within_pi, -phase, -id, -nr
          )
          mutate(map_est = map)
        })
      }
    )
    group_by(phase)
    mutate(not_mapped_phase = all(is.na(map)))
    ungroup
    mutate(map = ifelse(not_mapped_phase | within_pi == 0, map_est, map))
    filter(not_mapped_phase | within_pi | n_within_pi == 0)
    group_by(elint, phase)
    summarise(map = median(map))
    ungroup
    spread(elint, map)
    # guess mapping intensity of certain phases in case
    # target elements are not analyzed by reference point analysis
    x ~ { 
      miss <- Reduce(`|`, lapply(x, is.na))
      if(all(!miss)) return(x)
      x[miss, -1] <- pipeline({
        map2(
          list(t(xmap_df[names(x[-1])])),
          pmap(x[miss, -1], c),
          `-`
        )
        map(square)
        map(colSums, na.rm = TRUE)
        map(which.min)
        map(function(i) xmap_df[i, ])
        bind_rows
        `[`(names(x[-1]))
        map2(x[miss, -1], function(y, x) ifelse(is.na(x), y, x))
        bind_cols
      })
      x
    }
    save4qm(nm = saveas, saving = is.character(saveas))
  })

}


#' @export
#' @rdname cluster_centers
#' @param wd working directory which contains .qnt directory. Use current directory if NULL
#' @param dir_map ignored
qltmap_cls_centers <- function() {
  warning('qltmap_cls_centers is deprecated. Use cls_initialize instead.')
  cd <- getwd()
  on.exit(cd)
  setwd(wd)
  cluster_centers(phase_fine = phase_fine, qnt = qnt, xmap = qltmap, saving = saving)
}
formals(qltmap_cls_centers) <- c(wd = '.', dir_map, formals(cls_initialize))



