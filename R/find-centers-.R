#' Initialize centroids for [`cluster_xmap()`]
#'
#' Initial centroids are guessed by comaring data from
#' spot analysis and x-ray mapping.
#' First, phase identification is done on some pixels in X-ray maps which
#' is quantified by spot analysis.
#' Second, for each phase, [`median`] values of X-ray maps are utilized as
#' initial centroids.
#' Note that X-ray mapping inevitably involves multi-phase pixels, and
#' such pixels can be a member of training data set for initial centroids.
#' See ["Multi-phase pixels"](#multi-phase-pixels) section for
#' automatic and manual special cares on such pixels.
#'
#' @param xmap an `qm_xmap` class object generated by [`read_xmap()`]
#' @param qnt an `qm_qnt` class object generated by [`read_qnt()`]`
#' @param fine_phase
#'   A character vector to specify fine grained phases
#'   which tend to comprise multi-phase pixels.
#'   See ["Multi-phase pixels"](#multi-phase-pixels) section for details.
#' @param saveas File name to save result. `FALSE` if not saving.
#'
#' @section Multi-phase pixels:
#'   X-ray mapping inevitably involves multi-phase pixels,
#'   especially for fine-grained phases.
#'   When the multi-phase pixels are member of training data set,
#'   guessing initial centroids can be biased.
#'   This is why guessing centroids is based on [`median`] instead of [`mean`].
#'   However, if pixels to guess centroids for cetrtain phase are
#'   comprising a large number of or even a full of multi-phase pixels,
#'   [`median`] is still vulnerable.
#'   For example, refer to a reprinted figure 5 from
#'   [Yasumoto et al. (2018)](https://doi.org/10.2138/am-2018-6323CCBY), and
#'   captions in original article.
#'   Phases such as Amp, Di, and Pl are outlying the regression curves due to
#'   multi-phase pixels.
#'   For these phases, median values of peak X-ray intensities from
#'   X-ray mapping are unreliable values for initial centroids.
#'   Thus, training data set should exclude data points from multi-phase pixels.
#'
#'   \if{html}{\figure{yasumoto-etal-2018-ccby-fig05.png}{options: width=100\%}}
#'
#'   Multi-phase pixels are automatically excluded by defining them as
#'   data points outlying 99\% predictive intervals in a following model:
#'     \deqn{I_{i, \mathrm{map}} \sim Poisson(\beta_i I_{i, \mathrm{qnt}}),}{%
#'   I_{i, \mathrm{map}} \sim Poisson(\beta_i I_{i, \mathrm{qnt}}),}
#'   where
#'   \eqn{I_{i, \mathrm{map}}} and
#'   \eqn{I_{i, \mathrm{qnt}}} are peak X-ray intensities of an element, \eqn{i},
#'   from X-ray mapping and quantitative spot analysis, respectively.
#'   \eqn{\beta_i} is a regression coefficient for an element, \eqn{i}.
#'
#'   In case all data points for certain phase are regarded as multi-phase pixels
#'   automatically by the above model or manually by the `fine_phase` paramter,
#'   initial centroids are set to medians of predictions by the above model.
#'
#' @inherit qntmap-package references
#'
#' @importFrom data.table fwrite
#' @importFrom dplyr
#'   bind_cols bind_rows filter group_by mutate summarise ungroup
#' @importFrom matrixStats colSums2
#' @importFrom purrr map2 pmap
#' @importFrom rlang !! .data
#' @importFrom stats lsfit qnbinom median
#' @importFrom tidyr gather spread
#'
#' @export
find_centers <- function(
                         xmap,
                         qnt,
                         fine_phase = NULL,
                         saveas = "centers0.csv"
) {

  quantified <- names(xmap) %in% c("x", "y", qnt$elm$elint)

  tidy_epma(qnt = qnt, xmap = xmap, cluster = NULL) %>>%
    group_by(.data$phase) %>>%
    filter(all(is.na(.data$map)) | !is.na(.data$map)) %>>%
    ungroup %>>%
    mutate( # Let weights in OLS be 0 for phases specified by `fine_phase``
      w = `if`(is.null(!! fine_phase), 1, as.integer(.data$phase %nin% !! fine_phase))
    ) %>>%
    group_by(.data$elint) %>>% # Peform OLS and estimate 99% prediction interval
    mutate(
      .tmp = is.finite(.data$map),
      map_est =
        .data$pkint * 
        lsfit(
          x = .data$pkint[.data$.tmp], y = .data$map[.data$.tmp], 
          wt = .data$w[.data$.tmp], intercept = FALSE
        )$coef,
      .tmp = NULL,
      pi_L = qnbinom(0.005, .data$map_est, 0.5),
      pi_H = qnbinom(0.995, .data$map_est + 1, 0.5)
    ) %>>%
    group_by(.data$id) %>>%
    mutate(
      within_pi = all((.data$pi_L <= .data$map) & (.data$map <= .data$pi_H))
    ) %>>%
    # pi = prediction interval
    group_by(.data$elint, .data$phase) %>>%
    mutate(n_within_pi = sum(.data$within_pi)) %>>%
    ungroup %>>%
    select(
      "elint", "map", "map_est", "within_pi", "n_within_pi", "phase", "id", "nr"
    ) %>>%
    bind_rows(
      if (!all(quantified)) {
        . %>>%
          filter(.data$elint == .data$elint[1L]) %>>%
          select(-"elint", -"map", -"map_est") %>>%
          bind_cols(lapply(xmap[!quantified], `[`, .$nr)) %>>%
          gather(
            "elint", "map", -"within_pi", -"n_within_pi", -"phase", -"id", -"nr"
          ) %>>%
          mutate(map_est = .data$map)
      }
    ) %>>%
    group_by(.data$phase) %>>%
    mutate(not_mapped_phase = all(is.na(.data$map))) %>>%
    ungroup %>>%
    mutate(map = ifelse(
      .data$not_mapped_phase | .data$within_pi == 0, .data$map_est, .data$map)
    ) %>>%
    filter(
      .data$not_mapped_phase | .data$within_pi | .data$n_within_pi == 0
    ) %>>%
    group_by(.data$elint, .data$phase) %>>%
    summarise(map = median(.data$map)) %>>%
    ungroup %>>%
    spread("elint", "map") %>>%
    # guess mapping intensity of certain phases in case
    # target elements are not analyzed by reference point analysis
    (function(x) {
      miss <- Reduce(`|`, lapply(x, is.na))
      if (all(!miss)) return(x)
      x[miss, -1] <-
        map2(
          list(t(xmap[names(x[-1])])),
          pmap(x[miss, -1], c),
          `-`
        ) %>>%
        lapply(function(x) xmap[which.min(colSums2(square(x), na.rm = TRUE)), ]) %>>%
        bind_rows %>>%
        `[`(names(x[-1L])) %>>%
        map2(x[miss, -1L], function(y, x) ifelse(is.na(x), y, x)) %>>%
        bind_cols
      x
    })() %>>%
    prioritize(c("phase", .component)) %>>%
    save4qm(nm = saveas, saving = is.character(saveas))
}
