#' Initialize centroids for [`cluster_xmap()`]
#'
#' Initial centroids are guessed by comaring data from
#' spot analysis and x-ray mapping.
#' First, phase identification is done on some pixels in X-ray maps which
#' is quantified by spot analysis.
#' Second, for each phase, [`median`] values of X-ray maps are utilized as
#' initial centroids.
#' Note that X-ray mapping inevitably involves multi-phase pixels, and
#' such pixels can be a member of training data set for initial centroids.
#' See ["Multi-phase pixels"](#multi-phase-pixels) section for
#' automatic and manual special cares on such pixels.
#'
#' @param xmap an `qm_xmap` class object generated by [`read_xmap()`]
#' @param qnt an `qm_qnt` class object generated by [`read_qnt()`]`
#' @param fine_phase
#'   A character vector to specify fine grained phases
#'   which tend to comprise multi-phase pixels.
#'   See ["Multi-phase pixels"](#multi-phase-pixels) section for details.
#' @param saveas File name to save result. `FALSE` if not saving.
#'
#' @section Multi-phase pixels:
#'   X-ray mapping inevitably involves multi-phase pixels,
#'   especially for fine-grained phases.
#'   When the multi-phase pixels are member of training data set,
#'   guessing initial centroids can be biased.
#'   This is why guessing centroids is based on [`median`] instead of [`mean`].
#'   However, if pixels to guess centroids for cetrtain phase are
#'   comprising a large number of or even a full of multi-phase pixels,
#'   [`median`] is still vulnerable.
#'   For example, refer to a reprinted figure 5 from
#'   [Yasumoto et al. (2018)](https://doi.org/10.2138/am-2018-6323CCBY), and
#'   captions in original article.
#'   Phases such as Amp, Di, and Pl are outlying the regression curves due to
#'   multi-phase pixels.
#'   For these phases, median values of peak X-ray intensities from
#'   X-ray mapping are unreliable values for initial centroids.
#'   Thus, training data set should exclude data points from multi-phase pixels.
#'
#'   \if{html}{\figure{yasumoto-etal-2018-ccby-fig05.png}{options: width=100\%}}
#'
#'   Multi-phase pixels are automatically excluded by defining them as
#'   data points outlying 99\% predictive intervals in a following model:
#'     \deqn{I_{i, \mathrm{map}} \sim Poisson(\beta_i I_{i, \mathrm{qnt}}),}{%
#'   I_{i, \mathrm{map}} \sim Poisson(\beta_i I_{i, \mathrm{qnt}}),}
#'   where
#'   \eqn{I_{i, \mathrm{map}}} and
#'   \eqn{I_{i, \mathrm{qnt}}} are peak X-ray intensities of an element, \eqn{i},
#'   from X-ray mapping and quantitative spot analysis, respectively.
#'   \eqn{\beta_i} is a regression coefficient for an element, \eqn{i}.
#'
#'   In case all data points for certain phase are regarded as multi-phase pixels
#'   automatically by the above model or manually by the `fine_phase` paramter,
#'   initial centroids are set to medians of predictions by the above model.
#'
#' @inherit qntmap-package references
#'
#' @importFrom data.table fwrite
#' @importFrom dplyr
#'   bind_cols bind_rows filter group_by mutate summarise ungroup
#' @importFrom matrixStats colSums2
#' @importFrom purrr map2 pmap
#' @importFrom stats lsfit qnbinom median
#' @importFrom tidyr spread
#'
#' @export
find_centers <- function(
                         xmap,
                         qnt,
                         fine_phase = NULL,
                         saveas = "centers0.csv"
) {

  quantified <- names(xmap) %in% qnt$elm$elint
  xmap_df <- as.data.frame(lapply(xmap, unlist, use.names = FALSE))

  tidy_epma(qnt = qnt, xmap = xmap, cluster = NULL) %>>%
    group_by(phase) %>>%
    filter(all(is.na(map)) | !is.na(map)) %>>%
    ungroup %>>%
    mutate( # Let weights in OLS be 0 for phases specified by `fine_phase``
      w = if (is.null(fine_phase)) 1 else as.integer(phase %nin% fine_phase)
    ) %>>%
    group_by(elint) %>>% # Peform OLS and estimate 99% prediction interval
    mutate(
      .tmp = is.finite(map),
      map_est =
        pkint * lsfit(pkint[.tmp], map[.tmp], w[.tmp], intercept = FALSE)$coef,
      .tmp = NULL,
      pi_L = qnbinom(0.005, map_est, 0.5),
      pi_H = qnbinom(0.995, map_est + 1, 0.5)
    ) %>>%
    group_by(id) %>>%
    mutate(within_pi = all((pi_L <= map) & (map <= pi_H))) %>>%
    # pi = prediction interval
    group_by(elint, phase) %>>%
    mutate(n_within_pi = sum(within_pi)) %>>%
    ungroup %>>%
    select(elint, map, map_est, within_pi, n_within_pi, phase, id, nr) %>>%
    bind_rows(
      if (!all(quantified)) {
        . %>>%
          filter(elint == elint[1]) %>>%
          select(-elint, -map, -map_est) %>>%
          bind_cols(lapply(xmap_df[!quantified], `[`, .$nr)) %>>%
          gather(elint, map, -within_pi, -n_within_pi, -phase, -id, -nr) %>>%
          mutate(map_est = map)
      }
    ) %>>%
    group_by(phase) %>>%
    mutate(not_mapped_phase = all(is.na(map))) %>>%
    ungroup %>>%
    mutate(map = ifelse(not_mapped_phase | within_pi == 0, map_est, map)) %>>%
    filter(not_mapped_phase | within_pi | n_within_pi == 0) %>>%
    group_by(elint, phase) %>>%
    summarise(map = median(map)) %>>%
    ungroup %>>%
    spread(elint, map) %>>%
    # guess mapping intensity of certain phases in case
    # target elements are not analyzed by reference point analysis
    (function(x) {
      miss <- Reduce(`|`, lapply(x, is.na))
      if (all(!miss)) return(x)
      x[miss, -1] <-
        map2(
          list(t(xmap_df[names(x[-1])])),
          pmap(x[miss, -1], c),
          `-`
        ) %>>%
        lapply(function(x) xmap_df[which.min(colSums2(square(x), na.rm = TRUE)), ]) %>>%
        bind_rows %>>%
        `[`(names(x[-1])) %>>%
        map2(x[miss, -1], function(y, x) ifelse(is.na(x), y, x)) %>>%
        bind_cols
      x
    })() %>>%
    prioritize(c("phase", .component)) %>>%
    save4qm(nm = saveas, saving = is.character(saveas))
}
