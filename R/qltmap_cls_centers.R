#' Generate initial centroids for clustering
#'
#' @param wd working directory which contains .qnt directory. Use current directory if NULL
#' @param dir_map path to the directory which contains mapping data.
#' @param phase_fine fine grained phases which tend to be appear in multi-phase pixels e.g., c('Pl', 'Amp')
#' @param qnt an object generated by qnt_load or a path to the .RDS file created by qnt_load
#' @param qltmap an object generated by qltmap_load or a path to the .RDS file created by qltmap_load
#' @param saving file name to save. FALSE if not saving.
#'
#' @importFrom data.table as.data.table
#' @importFrom data.table fwrite
#' @importFrom dplyr bind_cols
#' @importFrom dplyr bind_rows
#' @importFrom dplyr filter
#' @importFrom dplyr group_by
#' @importFrom dplyr mutate
#' @importFrom dplyr summarise
#' @importFrom dplyr ungroup
#' @importFrom pipeR pipeline
#' @importFrom stats lm
#' @importFrom stats predict
#' @importFrom stats qnbinom
#' @importFrom stats median
#' @importFrom tidyr spread
#'
#' @export
cls_centers <- qltmap_cls_centers <- function(
  wd = '.',
  dir_map,
  phase_fine = NULL,
  qnt = read_qnt(wd),
  qltmap = read_xmap(dir_map),
  saving = 'centers_initial0.csv'
) {

  quantified <- names(qltmap) %in% qnt$elm$elint
  qltmap_df <- as.data.frame(lapply(qltmap, unlist, use.names = FALSE))
  
  pipeline({
    epma_tidy( # Compile spot/map analysis
      wd,
      dir_map,
      qnt = qnt,
      qltmap = qltmap,
      cluster = NA
    )
    group_by(phase)
    filter(all(is.na(map)) | !is.na(map))
    ungroup
    mutate( # Let weighting for least squares to be 0 for phases those who listed in phase_fine
      w = if(is.null(phase_fine)) 1 else as.integer(phase %nin% phase_fine)
    )
    group_by(elint) # Peform least squares and estimate 99% prediction interval
    mutate(
      map_est =
        pkint *
        lsfit(pkint[!is.na(map)], map[!is.na(map)], w[!is.na(map)], intercept = FALSE)$coef,
      pi_L = qnbinom(0.005, map_est, 0.5),
      pi_H = qnbinom(0.995, map_est + 1, 0.5)
    )
    group_by(id)
    mutate( # See if values are within prediction interval
      within_pi = all((pi_L <= map) & (map <= pi_H))
    )
    group_by(elint, phase)
    mutate(n_within_pi = sum(within_pi))
    ungroup
    select(elint, map, map_est, within_pi, n_within_pi, phase, id, nr)
    bind_rows(
      if(all(quantified)) {
        NULL
      } else {
        pipeline({
          .
          filter(elint == elint[1])
          select(-elint, -map, -map_est)
          bind_cols(
            lapply(qltmap_df[!quantified], `[`, .$nr)
          )
          gather(
            elint, map, -within_pi, -n_within_pi, -phase, -id, -nr
          )
          mutate(map_est = map)
        })
      }
    )
    group_by(phase)
    mutate(not_mapped_phase = all(is.na(map)))
    ungroup
    mutate(map = ifelse(not_mapped_phase | within_pi == 0, map_est, map))
    filter(not_mapped_phase | within_pi | n_within_pi == 0)
    group_by(elint, phase)
    summarise(map = median(map))
    ungroup
    spread(elint, map)
    # guess mapping intensity of certain phases in case
    # target elements are not analyzed by reference point analysis
    x ~ { 
      miss <- Reduce(`|`, lapply(x, is.na))
      if(all(!miss)) return(x)
      x[miss, -1] <- pipeline({
        map2(
          list(t(qltmap_df[names(x[-1])])),
          pmap(x[miss, -1], c),
          `-`
        )
        map(square)
        map(colSums, na.rm = TRUE)
        map(which.min)
        map(function(i) qltmap_df[i, ])
        bind_rows
        `[`(names(x[-1]))
        map2(x[miss, -1], function(y, x) ifelse(is.na(x), y, x))
        bind_cols
      })
      x
    }
    ~ if(is.character(saving)) fwrite(., saving)
  })

}









