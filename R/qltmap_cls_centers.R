#' Generate initial centroids for clustering
#'
#' @param wd working directory which contains .qnt directory. Use current directory if NULL
#' @param dir_map path to the directory which contains mapping data.
#' @param phase_fine fine grained phases which tend to be appear in multi-phase pixels e.g., c('Pl', 'Amp')
#' @param qnt an object generated by qnt_load or a path to the .RDS file created by qnt_load
#' @param qltmap an object generated by qltmap_load or a path to the .RDS file created by qltmap_load
#' @param saving file name to save. FALSE if not saving.
#'
#' @importFrom data.table as.data.table
#' @importFrom data.table fwrite
#' @importFrom dplyr bind_cols
#' @importFrom dplyr bind_rows
#' @importFrom dplyr filter
#' @importFrom dplyr group_by
#' @importFrom dplyr mutate
#' @importFrom dplyr summarise
#' @importFrom dplyr ungroup
#' @importFrom dplyr summarise
#' @importFrom pipeR pipeline
#' @importFrom stats lm
#' @importFrom stats predict
#' @importFrom stats qnbinom
#' @importFrom stats median
#' @importFrom tidyr spread
#'
#' @export
qltmap_cls_centers <- function(
  wd = NULL,
  dir_map,
  phase_fine = NULL,
  qnt = read_qnt(wd),
  qltmap = read_xmap(dir_map),
  saving = 'centers_initial0.csv'
) {

  epma_tidy( # Compile spot/map analysis
    wd,
    dir_map,
    qnt = qnt,
    qltmap = qltmap,
    cluster = NA
  ) %>>%
    group_by(phase) %>>%
    filter(all(is.na(map)) | !is.na(map)) %>>%
    ungroup() %>>%
    mutate( # Let weighting for least squares to be 0 for phases those who listed in phase_fine
      w = if(is.null(phase_fine)) 1 else as.integer(!(phase %in% phase_fine))
    ) %>>%
    group_by(elint) %>>% # Peform least squares and estimate 99% CI and PI
    mutate(
      map_est = 
        pkint * 
        lsfit(pkint[!is.na(map)], map[!is.na(map)], w[!is.na(map)], intercept = FALSE)$coef
    ) %>>%
    mutate(
      # map_ci_L99 = qgamma(0.005, map_est + 1, 1),
      # map_ci_H99 = qgamma(0.995, map_est + 1, 1),
      map_pi_L99 = qnbinom(0.005, map_est, 0.5),
      map_pi_H99 = qnbinom(0.995, map_est + 1, 0.5)
    ) %>>%
    group_by(id) %>>%
    mutate( # See if values are within CI or PI
      # within_ci = (map <= map_ci_H99) & (map >= map_ci_L99),
      within_pi = all((map <= map_pi_H99) & (map >= map_pi_L99))
    ) %>>%
    group_by(elint, phase) %>>%
    mutate(n_within_pi = sum(within_pi)) %>>%
    ungroup() %>>%
    select(elint, map, map_est, within_pi, n_within_pi, phase, id, nr) %>>%
    (.x ~ if(all(names(qltmap) %in% unique(.x$elint))) {
      .x
    } else {
      bind_rows(
        .x,
        .x %>>%
          filter(elint == elint[1]) %>>%
          select(-elint, -map, -map_est) %>>%
          c(lapply(
            (qltmap[-which(names(qltmap) %in% unique(.x$elint))] %>>%
              lapply(unlist, use.names = FALSE)),
            `[`,
            .$nr
          )) %>>%
          as.data.table %>>%
          gather(
            elint, map, -within_pi, -n_within_pi, -phase, -id, -nr
          )  %>>%
          mutate(map_est = map)
      )
    }) %>>%
    group_by(phase) %>>%
    mutate(not_mapped_phase = all(is.na(map))) %>>%
    ungroup() %>>%
    mutate(map = ifelse(not_mapped_phase | within_pi == 0, map_est, map)) %>>%
    # filter(within_ci) %>>%
    filter(not_mapped_phase | within_pi | n_within_pi == 0) %>>%
    group_by(elint, phase) %>>%
    summarise(map = median(map)) %>>%
    ungroup %>>%
    spread(elint, map) %>>%
    (~ if(is.character(saving)) fwrite(., saving)) %>>%
    # # (~ print(.)) %>>%
    return()

}
















